{"ast":null,"code":"import { findSpring, calcAngularFreq } from './find-spring.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\n\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false,\n    ...options\n  }; // stiffness/damping/mass overrides duration/bounce\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = { ...springOptions,\n      ...derived,\n      velocity: 0.0,\n      mass: 1.0\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nconst velocitySampleDuration = 5;\n/**\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\n */\n\nfunction spring(_ref) {\n  let {\n    keyframes,\n    restSpeed = 2,\n    restDelta = 0.01,\n    ...options\n  } = _ref;\n  let origin = keyframes[0];\n  let target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n\n  function createSpring() {\n    const initialDelta = target - origin;\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    /**\n     * If we're working within what looks like a 0-1 range, change the default restDelta\n     * to 0.01\n     */\n\n    if (restDelta === undefined) {\n      restDelta = Math.min(Math.abs(target - origin) / 100, 0.4);\n    }\n\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio); // Underdamped spring\n\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      // Critically damped spring\n      resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      // Overdamped spring\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t); // When performing sinh or cosh values can hit Infinity so we cap them here\n\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n\n  createSpring();\n  return {\n    next: t => {\n      const current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            const prevT = Math.max(0, t - velocitySampleDuration);\n            currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t - prevT);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? target : current;\n      return state;\n    },\n    flipTarget: () => {\n      initialVelocity = -initialVelocity;\n      [origin, target] = [target, origin];\n      createSpring();\n    }\n  };\n}\n\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\n\nconst zero = _t => 0;\n\nexport { spring };","map":{"version":3,"sources":["/Users/daitran/Desktop/portfolio-starter-master/node_modules/framer-motion/dist/es/animation/legacy-popmotion/spring.mjs"],"names":["findSpring","calcAngularFreq","velocityPerSecond","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","velocitySampleDuration","spring","keyframes","restSpeed","restDelta","origin","target","length","state","done","value","duration","resolveSpring","zero","initialVelocity","dampingRatio","Math","sqrt","createSpring","initialDelta","undampedAngularFreq","min","abs","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","next","current","currentVelocity","prevT","max","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","a","b","_t"],"mappings":"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","sourcesContent":["import { findSpring, calcAngularFreq } from './find-spring.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nconst velocitySampleDuration = 5;\n/**\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\n */\nfunction spring({ keyframes, restSpeed = 2, restDelta = 0.01, ...options }) {\n    let origin = keyframes[0];\n    let target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    function createSpring() {\n        const initialDelta = target - origin;\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        /**\n         * If we're working within what looks like a 0-1 range, change the default restDelta\n         * to 0.01\n         */\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(target - origin) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            // Underdamped spring\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (target -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            // Critically damped spring\n            resolveSpring = (t) => target -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            // Overdamped spring\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                // When performing sinh or cosh values can hit Infinity so we cap them here\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (target -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        const prevT = Math.max(0, t - velocitySampleDuration);\n                        currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t - prevT);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        flipTarget: () => {\n            initialVelocity = -initialVelocity;\n            [origin, target] = [target, origin];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t) => 0;\n\nexport { spring };\n"]},"metadata":{},"sourceType":"module"}